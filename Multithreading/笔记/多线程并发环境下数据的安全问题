多线程并发环境下数据的安全问题：
	在以后发开发中，我们的项目都是运行在服务器当中，而服务器已经将线程的定义、线程对象的创建、线程的启动等，都已经
实现完成了，这些代码我们都不需要编写；
	因此，最重要的，程序员要知道编写的程序需要放在一个多线程的环境下运行，因此更需要关注的是这些数据在多线程并发环境下
是否安全的问题；

什么时候数据在多线程并发环境下会存在安全问题？
	三个条件：
		1、多线程并发；
		2、有共享数据；
		3、共享数据有修改行为；
	满足一上三个条件之后，就会存在线程安全问题！！！
	
怎么解决线程安全的问题？
	在多线程环境下，有共享数据，并且数据还会被修改，此时就存在线程安全问题；
解决这个问题的方法：线程排队执行(不能并发)，即用排队执行解决线程安全问题，这种机制被称为"线程同步机制"；

线程同步机制就是线程排队机制，线程同步会牺牲一部分效率；

同步与异步理解
	异步编程模型：
		线程t1和线程t2，各自执行各自的，t1不管t2，t2不管t1，谁也不用等谁，效率较高，即多线程并发；
	同步编程模型：
		线程t1和线程t2，在线程t1执行时，必须等待t2线程执行结束；或者线程t2执行时，必须等待t1线程执行结束，
	两个线程之间发生了等待关系，效率较低，线程排队执行；
	
	
	
Java中线程同步使用的synchronized(){}语法:
	在synchronized(){}内的代码会线程排队执行(即一个线程把这里面的代码全部执行结束之后，另一个线程才能进来)，不能并发；
	线程同步机制的语法：
		synchronized() {
			// 线程同步代码块
		}
	
	synchronized关键字后面的小括号中传入的这个"数据"是相当关键的，这个数据必须是多线程共享的数据，这样才能实现多线程排队执行；
	
	synchronized表示“排他锁”；
	
	()中写什么？怎么写？
		主要看想让那些线程同步，如t1、t2、t3、t4、t5五个线程，若只希望t1、t2、t3这3个线程排队，t4、t5这2个线程不排队，那么就要在
	synchronized(){}的()内写入t1、t2、t3这3个线程共享的对象，而且这个对象对于t4、t5这2个线程来说是不共享的；



synchronized(){}的线程同步的执行原理
	Java语言中,每个对象都有一把锁(100个对象100把锁),其实这把锁就是一个标记;
	如:
		1、假设现有t1、t2两个线程并发，开始执行synchronized(){}内的代码时肯定有先有后；
		2、假设t1线程先遇到synchronized关键字，这时会自动找synchronized的()内的共享对象的对象锁，在找到之后，其会占有这把锁，
		然后执行synchronized(){}的{}内的代码，在执行内部的代码的过程中一直会占有这把锁，直到{}内的代码执行完毕，这把锁才会释放；
		3、此时如果t2线程也遇到synchronized关键字，这时会自动找synchronized的()内的共享对象的对象锁，在找到之后，其会占有这把锁，
		但是此时这把锁已经被t1占有，t2只能在同步代码块外面等待t1的结束，直到t1将同步代码块执行完毕，t1就归还这把锁，此时t2等到这
		把锁，然后t2占有这把锁，进入同步代码块执行程序；
	通过上面的这个例子，可以看到实现了线程排队执行，这里需要注意：这个共享对象一定要选好，这个共享对象一定是你需要排队执行的这些线
	程对象所共享的；
	
	注意：同步代码块越小，即{}内的代码越少，效率越高；反之效率越低；
	
	
Java中的三大变量：
	实例变量：存储在堆中；
	静态变量：存储在方法区中；
	局部变量：存储在栈中；
	
	以上的三大变量中，局部变量永远都不会存在线程安全问题，因为局部变量不共享(一个线程一个栈)，局部变量存储在栈中，因此局部变量永远
	都不会共享，所以局部变量永远都不会存在线程安全问题；
	而实例变量存储在堆中，且堆只有一个；静态变量存储在方法区中，且方法区只有一个；堆和方法区都是多线程共享的，所以可能存在线程安全问题；
	
	结论：局部变量和常量没有线程安全问题，成员变量(实例变量、静态变量)可能会有线程安全问题；
	
	
	
对String字符串，如果是局部变量使用(局部变量没有线程安全问题)，建议使用StringBuilder(非线程安全)，避免影响效率；

总结：
	synchronized的几种写法：
		第一种：同步代码块：
			使用较灵活
			synchronized(线程同步的共享对象) {
				// 同步代码块
			}
			
		第二种：在实例方法上使用synchronized关键字：
			表示共享对象是this，并且同步代码块是整个方法体
			public/private/protected synchronized 返回值类型 方法名(参数列表) {
			}
			
		第三种：在静态方法上使用synchronized关键字：
			表示找类锁；
			注意：类锁永远只有1把，就算这个类创建了100个对象，类锁也只有1把！！！
				类锁是保证静态变量的安全，对象锁保证实例变量的安全；
				
				
				
开发中怎么解决线程安全问题？
	synchronized会让程序的执行效率降低，用户体验不好，系统的用户吞吐量(并发量)降低，用户体验差，在不得已的情况下再选择线程同步机制(synchronized)
	优先考虑：尽量使用 "局部变量" 代替 "实例变量和静态变量"；
	其次考虑：如果不能使用 "局部变量" ，只能是 "实例变量" ，那么可以考虑创建多个对象，这样实例变量的内存就不共享了。(即1个线程对应1个对象，100个线程对应100个对象，
	数据不共享就没有数据安全问题了)；
	最次考虑：如果不能使用局部变量，并且不能创建多个对象，此时只能选择线程同步机制(synchronized)；
	
	
	
之后的内容：
	1、守护线程
	2、定时器
	3、实现线程的第三种方式：FutureTask方式，实现Callable接口。(JDK8新特性)
	4、关于Object类中的wait()方法和notify()方法；(生产者和消费者模式)