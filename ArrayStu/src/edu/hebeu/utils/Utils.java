package edu.hebeu.utils;

public class Utils {
	
	/**
	 * 冒泡排序:每次使用当前的数据a与当前数据的后一个数据b比较，如果a > b, 则交换；反之，不交换
	 * 第一次循环下来，最右边的值就是本数组内的最大值，在进行之后的循环，比较其他的数据，
	 * 如此将大的数以此排放至右侧，实现从左到右的从小到大数据排列
	 * 
	 * 如，原始数据为：{1, 5, 8, 0, 99, 52, 31}
	 * 第一次循环：
	 * 		第一次比较："1", "5", 8, 0, 99, 52, 31	(1 < 5, 不交换)
	 *  	第二次比较：1, "5", "8", 0, 99, 52, 31	(5 < 8, 不交换)
	 *  	第三次比较：1, 5, "8", "0", 99, 52, 31	(8 > 0, 交换)
	 *  	第四次比较：1, 5, 0, "8", "99", 52, 31	(8 < 99, 不交换)
	 *  	第五次比较：1, 5, 0, 8, "99", "52", 31	(99 > 52, 交换)
	 *  	第六次比较：1, 5, 0, 8, 52, "99", "31"	(99 > 31, 交换)
	 *  第一次循环比较的结果：{1, 5, 0, 8, 52, 31, 99}
	 *  
	 * 此时待比较的数据：{1, 5, 0, 8, 52, 31}
	 * 第二次循环：
	 * 		第一次比较："1", "5", 0, 8, 52, 31	(1 < 5, 不交换)
	 * 		第二次比较：1, "5", "0", 8, 52, 31	(5 > 0, 交换)
	 * 		第三次比较：1, 0, "5", "8", 52, 31	(5 < 8, 不交换)
	 * 		第四次比较：1, 0, 5, "8", "52", 31	(8 < 52, 不交换)
	 * 		第五次比较：1, 0, 5, 8, "52", "31"	(52 > 31, 交换)
	 * 	第二次循环比较的结果：{1, 0, 5, 8, 31, 52}
	 * 
	 * 此时待比较的数据：{1, 0, 5, 8, 31}
	 * 第三次循环：
	 * 		第一次比较："1", "0", 5, 8, 31	(1 > 0, 交换)
	 * 		第二次比较：0, "1", "5", 8, 31	(1 < 5, 不交换)
	 * 		第三次比较：0, 1, "5", "8", 31	(5 < 8, 不交换)
	 * 		第四次比较：0, 1, 5, "8", "31"	(8 < 31, 不交换)
	 * 	第三次循环比较的结果：{0, 1, 5, 8, 31}
	 * 
	 * 此时待比较的数据：{0, 1, 5, 8}
	 * 第四次循环：
	 * 		第一次比较："0", "1", 5, 8	(0 < 1, 不交换)
	 * 		第二次比较："0", "1", 5, 8	(0 < 1, 不交换)
	 * 		第三次比较："0", "1", 5, 8	(0 < 1, 不交换)
	 * 	第四次循环比较的结果：{0, 1, 5, 8}
	 * 
	 * 此时待比较的数据：{0, 1, 5}
	 * 第五次循环：
	 * 		第一次比较："0", "1", 5	(0 < 1, 不交换)
	 * 		第二次比较：0, "1", "5"	(1 < 5, 不交换)
	 * 	第五次循环比较多结果：{0, 1, 5}
	 * 
	 * 此时待比较的数据：{0, 1}
	 * 第六次循环：
	 * 		第一次比较："0", "1"	(0 < 1, 不交换)
	 * 	第六次循环比较的结果：{0, 1}
	 * 
	 * 综上分析：冒泡排序算法共进行 (数组的长度 - 1) 次循环，每次循环共进行 (数组长度 - 当前循环的次数) 次比较
	 * 
	 * 最终排序结果：{0, 1, 5, 8, 31, 52, 99}
	 * @param array
	 */
	public static void bubblingSort(int[] array) {
		for(int i = array.length - 1; i > 0; i--) { // 进行 (数组长度 - 1) 次循环
			for(int j = 0; j < i; j++) { // 当前循环进行 (数组长度 - 当前循环次数) 次比较
				int temp = 0;
				if(array[j] > array[j + 1]) { // 如果当前的元素比其后一个元素大
					/*进行交换*/
					temp = array[j + 1];
					array[j + 1] = array[j];
					array[j] = temp;
				}
			}
		}
	}
	
	/**
	 * 选择排序：每次从待排序的数据中找到值最小的数据，将此数据与待排序数据的最左边数据进行交换，直至左边的数据都经过比较
	 * 相比于冒泡排序，选择排序的效率更高，高在交换次数上，因为选择排序每次的交换都是有意义的
	 * 
	 * 如：原始数据为：{0, 5, 88, 3, 6, 7}
	 * 第一次循环："0", 5, 88, 3, 6, 7	(最左边的数据为0，其下标为0；最小数据为0，其下标为0，进行交换)
	 * 	第一次循环结果：{0, 5, 88, 3, 6, 7}
	 * 
	 * 此时待排序的数据为：{5, 88, 3, 6, 7}
	 * 第二次循环：5, 88, "3", 6, 7	(最左边数据为5，其下标为1；最小数据为3，其下标为3，进行交换)
	 * 	第二次循环结果：{3, 88, 5, 6, 7}
	 * 
	 * 此时待排序数据为：{88, 5, 6, 7}
	 * 第三次循环：88, "5", 6, 7	(最左边数据为88，其小标为2；最小数据为5，其小标为3，进行交换)
	 * 	第三次循环结果：{5, 88, 6, 7}
	 * 
	 * 此时待排序数据为：{88, 6, 7}
	 * 第四次循环：88, "6", 7	(最左边数据为88，其下标为3；最小数据为6，其下标为4，进行交换)
	 * 	第四次循环结果：{6, 88, 7}
	 * 
	 * 此时待排序数据为：{88, 7}
	 * 第五次循环：88, "7"	(最左边数据为88，其下标为4；最小数据为7，其下标为5，进行交换)
	 * 第五次循环结果：{7, 88}
	 * 
	 * 最终结果，从左至右从小到大为：{0, 3, 5, 6, 7, 88}
	 * 
	 * 分析：待排序区数据的最左边数据的下标可以通过for循环取到，
	 * 
	 * @param array
	 */
	public static void selectSort(int[] array) {
		for(int i = 0; i < array.length - 1; i++) { // 获取待排序区最左边的下标
			
			int minSubScript = i; // 待排序区的最小值的下标,猜想为当前待排序数据的最左边下标为i(即猜想待排序区最左边下标值就是待排序区元素最小值的下标)
			for(int j = i + 1; j < array.length; j++) { // 遍历待排序区除最左边数据的其他数据，用来选出最小值的下标
//				System.out.println("array[j]=" + array[j]);
//				System.out.println("array[minSubScript]=" + array[minSubScript]);
				if(array[j] < array[minSubScript]) { // 如果有元素小于最初猜想的最左边的数据，即猜想失败，将最小下标修改为此元素
					minSubScript = j;
				}
			}			
//			System.out.println("最左边下标=" + i);
//			System.out.println("minSubScript=" + minSubScript);
			
			/**实现待排序区的最小值与待排序区的最左边值进行交换*/
			if(minSubScript != i) { // 如果最小值的下标不等于最初猜想的最左边元素i，则将最左边元素i与最小元素minSubScript进行交换
				int temp = 0;
				temp = array[minSubScript];
				array[minSubScript] = array[i];
				array[i] = temp;
			}
		}
	}
	
	/**
	 * 二分查找(折半查找)：在数组是有序的前提下(本方法是升序)，通过 中间下标的值 与 待查询的元素值 进行比较，将 待查询的数组 一分为二，
	 *
	 * 如果 中间元素的值 > 待查询元素值，则表示 待查询的元素在中间元素的左边，
	 * 		开始下标不变，结束下标变成中间下标 - 1，中间下标变成(开始下标 + 结束下标) / 2
	 * 		此时应该对左边的数组采用上述的方法；
	 * 如果 中间元素的值 < 待查询元素值，则表示 待查询的元素在中间元素的右边，
	 * 		开始下标变成中间下标 + 1，结束下标不变，中间下标变成(开始下标 + 结束下标) / 2
	 * 		此时应该对右边的数组采用上述的方法；
	 * 
	 * 分析：定义一个startSubScript开始下标初始为0，endSubScript结束下标初始为数组的长度 - 1，中间下标midSubScript初始为(开始下标 + 结束下标) / 2
	 * @param array 待查询的数组
	 * @param dest 待查询值
	 * @return 返回查询出的下标，如果 >= 0, 则表示找到了此元素的下标；如果 == -1, 表示未找到此元素
	 */
	public static int dichotomySelect(int[] array, int dest) {
		int startSubScript = 0; // 开始下标
		int endSubScript = array.length - 1; // 结束下标
		
		while(startSubScript <= endSubScript) { // 如果开始下标小于或者等于结束下标，即表示数组已经切分完了，此时就结束循环也就代表了没有找到要查询的元素
			int midSubScript = (startSubScript + endSubScript) / 2; // 中间下标
			if(array[midSubScript] == dest) { // 如果中间下标的值等于要查找的元素值，即找到了此元素
				return midSubScript; // 返回此下标
			} else if(array[midSubScript] > dest) { // 如果中间下标的值大于要查找的元素值，即要查找的元素在中间下标的左边
//				System.out.println("在左边");
				endSubScript = midSubScript - 1; // 将结束下标变成中间下标 - 1
			} else if(array[midSubScript] < dest) { // 如果中间下标的值小于要查找的元素值，即要查找的元素在中间下标的右边
//				System.out.println("在右边");
				startSubScript = midSubScript + 1; // 将开始下标变成中间下标 + 1
			}			
		}
		
		/**程序到此表示未找到要查找的元素*/
		return -1;
	}
	
	/**
	 * 打印数组方法
	 * @param array
	 */
	public static void printArrays(int[] array) {
		System.out.print("[");
		for(int i = 0; i < array.length; i++) {
			System.out.print(array[i]);
			if(i < array.length - 1) {
				System.out.print(", ");
			}
		}
		System.out.println("]");
	}
}
